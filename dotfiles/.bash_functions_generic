function xpid()
{(
	xprop | grep PID | awk '{print $NF}'
)}

function ded()
{(
	find . -type d -empty -delete
)}

function def()
{(
	find . -type f -empty -delete
)}

function ds()
{(
    find . -maxdepth 1 -exec du -hs "{}" \; | sort -h
)}

alias dsf='dsd'
function dsd()
{(
    find . -maxdepth 1 -type d -exec du -hs "{}" \; | sort -h
)}

function mcd()
{
	dir="$1"

	if [ ! -d "$dir" ]; then
		mkdir -p "$dir"
	fi

	cd "$dir"
}

function sort-by-alpha()
{(
	# get the first letter of each file and directory in the current directory
	# move all files and directories into their respective single letter directory
	# if any files are left put them into the misc/ directory
	ls | \
		cut -c1 | \
		sort -u | \
		grep -E -e "[[:alpha:]]" | \
		while read line; do
			mkdir -p "$line"
			mv "$line"* "$line/" 2>/dev/null
		done
	
	files_left="$(find . -maxdepth 1 -type f | wc -l)"

	if [[ "$files_left" != "0" ]]; then
		mkdir -p misc
		find . -maxdepth 1 -type f -exec mv "{}" misc/ \;
	fi
)}

function randnum()
{(
	first_num="$1"
	second_num="$2"

	if [[ -z "$first_num" ]]; then
		echo "$FUNCNAME: <max number> <optional: end number, if used max number becomes starting number>"
		return 1
	fi

	if [[ -z "$second_num" ]]; then
		second_num="$first_num"
		first_num="0"
	else
		second_num="$(( $second_num - $first_num ))"
	fi

	echo "$(( ($RANDOM % ($second_num + 1)) + $first_num ))"
)}

# All *wait* functions were created for simple command-line scripting purposes
# If inotifywait is available on the system it would likely be a better solution

function pwait()
{(
	process="$1"

	if [[ -z "$process" ]]; then
		echo "$FUNCNAME: <process name regex> <optional: number of minutes to sleep, 1 minute by default>"
		echo "Wait until a named process no longer exists."
		return 1
	fi

	wait="1"
	
	if [[ ! -z "$2" ]]; then
		wait="$2"
	fi

	until ! pgrep "$process" &>/dev/null; do
		echo "waiting $wait minute(s)... [process: $process]"
		sleep "$wait""m"
	done
)}

function mwait()
{(
	file="$1"

	if [[ -z "$file" ]]; then
		echo "$FUNCNAME: <file> <optional: number of minutes to sleep, 1 minute by default>"
		echo "Wait until the file modification time has changed."
		return 1
	fi

	wait="1"
	
	if [[ ! -z "$2" ]]; then
		wait="$2"
	fi

	if [[ ! -f "$file" ]]; then
		echo "File not found: $file"
		return 1
	fi

	file_mod_time="$(stat -c"%Y" "$file")"

	until [[ ! -f "$file" || ( "$file_mod_time" != "$(stat -c"%Y" "$file")" ) ]]; do
		echo "waiting $wait minute(s)... [file: $file]"
		sleep "$wait""m"
	done
)}

function fwait()
{(
	file="$1"

	if [[ -z "$file" ]]; then
		echo "$FUNCNAME: <file> <optional: number of minutes to sleep, 1 minute by default>"
		echo "Wait until the file contents have changed."
		return 1
	fi

	wait="1"
	
	if [[ ! -z "$2" ]]; then
		wait="$2"
	fi

	if [[ ! -f "$file" ]]; then
		echo "File not found: $file"
		return 1
	fi

	file_hash="$(sha1sum "$file" | cut -f1 -d' ')"
	file_mod_time="$(stat -c"%Y" "$file")"

	until [[ ! -f "$file" || ( ( "$file_mod_time" != "$(stat -c"%Y" "$file")" ) && ( "$file_hash" != "$(sha1sum "$file" | cut -f1 -d' ')" ) ) ]]; do
		echo "waiting $wait minute(s)... [file: $file]"
		sleep "$wait""m"
	done
)}

function dwait()
{(
	dir="$1"

	if [[ -z "$dir" ]]; then
		echo "$FUNCNAME: <dir> <optional: number of minutes to sleep, 1 minute by default>"
		echo "Wait until the directory has had contents removed, added, or changed."
		return 1
	fi

	wait="1"
	
	if [[ ! -z "$2" ]]; then
		wait="$2"
	fi

	if [[ ! -d "$dir" ]]; then
		echo "Directory not found: $dir"
		return 1
	fi

	dir_hash="$(find "$dir" -exec stat -c "%i %Y" "{}" \; 2>/dev/null | sha1sum)"

	until [[ ! -d "$dir" || ( "$dir_hash" != "$(find "$dir" -exec stat -c "%i %Y" "{}" \; 2>/dev/null | sha1sum)" ) ]]; do
		echo "waiting $wait minute(s)... [dir: $dir]"
		sleep "$wait""m"
	done
)}

function dnwait()
{(
	dir="$1"

	if [[ -z "$dir" ]]; then
		echo "$FUNCNAME: <dir> <optional: number of minutes to sleep, 1 minute by default>"
		echo "Wait until the directory has stopped having contents removed, added, or changed."
		return 1
	fi

	wait="1"
	
	if [[ ! -z "$2" ]]; then
		wait="$2"
	fi

	if [[ ! -d "$dir" ]]; then
		echo "Directory not found: $dir"
		return 1
	fi

	dir_hash=""

	until [[ ( $dir_hash != "" ) && ( ! -d "$dir" || ( "$dir_hash" == "$(find "$dir" -exec stat -c "%i %Y" "{}" \; 2>/dev/null | sha1sum)" ) ) ]]; do
		dir_hash="$(find "$dir" -exec stat -c "%i %Y" "{}" \; 2>/dev/null | sha1sum)"
		echo "waiting $wait minute(s)... [dir: $dir]"
		sleep "$wait""m"
	done
)}

function rename-to-numbers()
{(
    starting_number="$1"

    if [[ -z "$starting_number" ]]; then
        starting_number=1
    fi

    tmp_file="$(mktemp)"
    declare -A filenames=()

    find . -maxdepth 1 -type f | \
        awk -F. -vi="$starting_number" '{
                                            ofile=$0
                                            nfile="./"i

                                            # if the file has an extension add
                                            # it back when renaming the file
                                            if (NF > 2)
                                            {
                                                nfile=nfile"."$NF
                                            }

                                            print ofile"\t"nfile

                                            i++
                                        }' > "$tmp_file"
    
    while read line; do
        ofile="$(echo "$line" | cut -f1)"
        nfile="$(echo "$line" | cut -f2)"

        if [[ "$ofile" != "$nfile" ]]; then
            filenames["$ofile"]="$nfile"
        fi
    done < "$tmp_file"

    while [[ "${#filenames[@]}" -gt "0" ]]; do
        for ofile in "${!filenames[@]}"; do 
            nfile="${filenames["$ofile"]}"

            if [[ ! -f "$nfile" ]]; then
                mv --no-clobber "$ofile" "$nfile"
                unset "filenames["$ofile"]"
            fi
        done
    done
)}

function ya()
{(
	num_of_videos_to_get="$1"
    
    format="22/18"
    
    if [[ ! -z "$2" ]]; then
        format="$2"
    fi

    if [[ "$format" != "none" ]]; then
        opt="--format "$format""
        echo "Specifying the video format: $format"
    else
        echo 'Not specifying a video format...'
    fi

	if [[ -r ~/Downloads/youtube.com_cookies.txt ]]; then
		opt="$opt --cookies ~/Downloads/youtube.com_cookies.txt"
        echo 'Found and using Youtube cookies...'
    else
        echo 'No Youtube cookies found...'
	fi

	if [[ (! -z "$num_of_videos_to_get") && ("$num_of_videos_to_get" -gt 0) ]]; then
		opt="$opt --playlist-end="$num_of_videos_to_get" --max-downloads=$num_of_videos_to_get"
        echo "Only downloading $num_of_videos_to_get videos..."
	fi
	

    # possibly useful youtube-dl options: --user-agent, --referer, --sleep-interval
	youtube-dl --continue --ignore-errors --youtube-skip-dash-manifest --restrict-filenames \
		--no-call-home --no-warnings --no-check-certificate --retries 'infinite' --fragment-retries 'infinite' \
        --batch-file a \
        --external-downloader aria2c \
        --external-downloader-args "--max-concurrent-downloads=1 --max-connection-per-server=4 --max-tries=0 --retry-wait=5 --split=4 --console-log-level='error' --log-level='error' --summary-interval=0" \
		$opt
)}

function yaq()
{(
    ya "$1" "bestvideo+bestaudio"
)}

function yaa()
{(
    ya "$1" "251/250/249/140"
)}

function yag()
{(
    ya "$1" "none"
)}

function uzrm()
{(
	zip_file="$1"

    unzip "$zip_file" && \
        rm "$zip_file"
)}
